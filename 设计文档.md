### 一、 设计目的 

#### 1.1功能与要求

该项目由为CS架构，分为客户端和服务端，用于实现多人在线语音聊天，具体需求如下。

**账号系统**

1. 支持用户注册，登录和退出。
2. 用户注册需要提供用户名和密码，用户名不可重复。

**房间**

1. 用户登录后可以创建房间，每个房间有且只有一个主持人，创建者默认为主持人，主持人可以转让给其他人。
2. 房间可以同时存在多个。
3. 房间内的用户可以听到其他用户的声音。
4. 主持人可以将若干指定用户静音，静音后所有用户不再听到被静音用户的声音，被静音用户可以主动解除静音。
5. 主持人可以将若干指定用户踢出房间。
6. 房间存在一个唯一6位数字ID，登录用户可以输入该ID加入一个房间。
7. 登录用户可以查看当前所有房间，并可选择其中一个加入。
8. 主持人退出后，房间自动解散，其他人自动退出房间。

**语音聊天**

1. 用户可以指定声音来源（包括麦克风和扬声器，可能有多个）。
2. 在正常网络下，声音每分钟明显卡顿次数小于1次，无明显延迟感。
3. 用户可以关闭房间内指定用户的声音。
4. 用户可以调节房间内指定用户的音量。

#### 1.2 环境选择

客户端的实现使用的是**Windows10**操作系统下的**QT5.12.5**, Qt是一个多平台的C++图形用户界面应用程序框架。

服务器使用的是**ubuntu18.04**,64位版本,同样安装qt作为开发环境;

数据库使用的是Linux **MySQL5.7**。

### 二、客户端设计

#### 2.1网络模块

由于音频占用带宽不大，项目暂定使用**tcp**协议保证可靠性，后续考虑高并发可替换为udp。

定义函数：

- 网络初始化init();
- 连接到服务器connectToServer();
- 发送数据：sendData();
- 每次发送的数据，要对不同的请求加入不同的头部，头部可以通过const完成定义。

#### 2.2登录和注册界面

![image-20210806115503046](C:\Users\user\Desktop\设计文档.assets\image-20210806115503046.png)

![image-20210806115518295](C:\Users\user\Desktop\设计文档.assets\image-20210806115518295.png)

登录注册，单击登录和注册窗口时发送信号，将用户名和密码传输给服务器。

```c++
SIG_loginReq(QString name , QString password);
SIG_registerReq(QString name , QString passord);
```

客户端界面的按钮之间的事件处理以及输入的合法性验证过程略。

服务器收到内容后做进一步处理。

- 关于登录, 处理登录请求, 先根据用户名查表取密码, 如果没有, 那么没有该用户；有的话, 比对密码 是否一致, 不一致, 返回密码错误, 一致返回登录成功。
- 关于注册，根据用户名判断是否重复，没有重复的话验证两次密码输入是否一致，一致的话通过md5加密后存入数据库，返回登录界面。
- 除此之外，登录后还需要有获取房间列表功能。

登录加密的方法:

- MD5加密
- 验证码防止脚本攻击
- 记录上次登录ip，地址等进行安全提示
- 手机验证码
- 绑定微信扫一扫登录
- 人脸识别。。。

#### 2.3会议模块

##### 2.3.1创建房间

![image-20210806161236209](C:\Users\user\Desktop\设计文档.assets\image-20210806161236209.png)
客户端单击星星图标发送信号，向服务端发送创建房间请求，服务器随机生成房间号返回。

```
SIG_createRoom();
```

##### 2.3.2加入房间

客户端搜索房间号或单击房间列表中的房间发送信号，向服务端发送加入房间请求，服务器将客户端添加至房间列表，给房间的每一个客户端发送成员列表。

```
SIG_joinRoom(int num);
```



![image-20210806162521048](C:\Users\user\Desktop\设计文档.assets\image-20210806162521048.png)

##### 2.3.3退出房间

客户端单击x或者退出房间时回收房间资源，发送信号。服务器收到某客户端退出房间的请求后，查找房间，得到用户列表,向每一个客户端发送客户端退出房间提示，每一个客户端接受数据后删除退出的客户端的资源。

```c++
SIG_quitRoom();//客户端向服务器发出退出信号
SIG_clientQuit();//服务器向客户端发出某个客户端退出信号
```

#### 2.4音频模块

##### 2.4.1基本流程和概念

对于音频，需要采集电脑麦克风声音，采用QAudioInput和QAudioOutput模块完成。

音频方面需要**编码后再传输**，编码选择 **ffmpeg** 进行处理。音频的主要流程：

![image-20210806164059828](C:\Users\user\Desktop\设计文档.assets\image-20210806164059828.png)

​        语音采集指的是从麦克风采集音频数据，即声音样本转换成数字信号。编码可以极大的减小带宽。目前有很多常用的语音编码技术，像 **G.729、G.711、.iLBC、AAC、SPEEX** 等等。

​        当一个音频帧完成编码后，即可通过网络发送给通话的对方。语音对话对于低延迟和平稳性要求较高，这就要求我们的**网络传送非常顺畅**。

​       当对方接收到编码帧后，会对其进行**解码**，以恢复成为可供声卡直接播放的数据。完成解码后，即可将得到的音频帧提交给声卡进行播放。

此外，还需要考虑一些问题：**回音消除、降噪、抑制声音断断续续、静音检测、混音**等。

- 低延迟
  - 主要取决于网络波动和双方的物理位置的距离，就单纯软件的角度，优化的可能性很小。
- 回音消除：
  - 扬声器播放时，电脑外部声音被麦克风再次采集，造成回音。 回音消除的原理简单地来说就是，回音消除模块依据刚播放的音频帧，在采集的音频帧中做一些**类似抵消的运算**，从而将回声从采集帧中清除掉。现在做的比较好的回音消除有：**webrtc。**
- 噪声抑制：
  - 噪声抑制又称为降噪处理，是根据语音数据的特点，将属于背景噪音的部分识别出来，并从音频帧中过滤掉。有很多**编码器都内置**了该功能。
- 抖动缓冲区：
  - 抖动缓冲区（JitterBuffer）用于**解决网络抖动**的问题。所谓网络抖动，就是**网络延迟一会大一会小**， 在这种情况下，即使发送方是定时发送数据包的接收方很难保证定时接收，导致听到的声音就是一卡一卡的。 JitterBuffer 工作于解码器之后，语音播放之前的环节。即语音解码完成后，将解码帧放入 JitterBuffer，声卡的播放回调到来时，从 JitterBuffer 中取出最老的一帧进行播放。**JitterBuffer 是利用了较高的延迟来换取声音的流畅播放的**，因为可以调节缓冲深度来平衡网络延迟。
- 静音检测：
  -  静音检测通常也**集成在编码模块**中。**如果没有语音输入，可以在编码头部设置特殊字符来表示**。
- 混音：
  - 在视频会议中，多人同时发言时，我们需要同时播放来自于多个人的语音数据，**而声卡播放的缓冲区只有一个，所以，需要将多路语音混合成一路**，这就是混音算法要做的事情。

##### 2.4.2带宽计算

以较优异的音质效果计算，采样率48KHz，采样位数16bit，双声道计算无损无压缩格式位1536kbps。考虑采用ffmpeg对音频进行压缩，大概能压缩到128kbps左右。

##### 2.4.3音频采集

逻辑：

- 客户端接收(read)到电脑内部的声音，利用定时器每隔50ms发送(write)缓冲区的数据给服务端；`readDataAndProcess()`
- 客户端接收(read)到服务端发来数据，进行处理。`SLOT_PlayAudio()`
- 服务端接收(read)到客户端发来的数据，处理后发送(write)给每一个客户端。

调用QAudioInput库进行音频采集，QIODevice创建缓冲区数据保存。调用QTimer创建定时器，每50ms从缓冲区采集一次数据，进行优化处理（编码、回音消除、降噪等）后发送信号SIG_AudioDataReady给主函数，主函数定义槽SLOT_sendAudioData向服务端发送数据。

主函数dealAudioData接收音频数据。

TODO：

静音检测。需要实现音频采集暂停函数，采集重写开始函数等。

```c++
//利用定时器，每隔50ms触发事件，执行readDataAndProcess函数。
connect(timer, &QTimer::timeout, this, &Audio_Read::readDataAndProcess);
//读取数据到缓冲区，并进行降噪、编码等处理。
readDataAndProcess();
//处理完毕后emit处理完毕信号
SIG_AudioDataReady(QByteArray);
//主函数中槽函数，用来发送缓冲区的数据给服务端
SLOT_sendAudioData();
//为主函数提供接口，将接收到的音频数据进行解压，混音等操作，调用QIODevice的write函数播放声音。
SLOT_PlayAudio();
```

编解码考虑利用speex的库函数直接完成，静音和降噪考虑使用webrtc的库函数直接完成，混音考虑采用ffmpeg库函数直接完成。

#### 2.5视频模块(TODO)

##### 2.5.1基本流程和概念

![image-20210806171457257](C:\Users\user\Desktop\设计文档.assets\image-20210806171457257.png)

##### 2.5.2带宽计算

​        以1920x1080的1080p视频计算，需要1920×1080=2,073,600，大约200w像素点，每个像素点包含RGB3字节工24bit，因此总共49,766,400bit，约5.9MB。以24fps计算，约**1,194,393,600‬bit=149,299,200‬byte**（8bit 比特=1byte 字节），就是142MB。

​        **YUV**代表亮度和色度，因为**RGB不利于压缩**。**通常用的是YUV4:2:0的采样方式**，能获得1/2的压缩率。

​        目前比较流行的编码格式有**H.264，H.265**。后者可以达到300的压缩率。**码流（视频文件在单位时间内使用的数据流量）**就是：**1,194,393,600‬bit ÷ 300 = 3,981,312 bit/s=3888Kbs**。

视频加音频，就是 **3,981,312 bps** + 192 kbps = 4,080 kbps。

如果要做的话可以考虑**opencv**，直接读取每一帧。

#### 2.6退出检测(TODO)

用户掉线，无法发送退出信号，借鉴tcp定时检测机制。创建定时器，完成心跳检测。

#### 2.7聊天、文件传输、断点续传(TODO)

#### 2.8客户端主函数

客户端主函数设立多个槽函数，用来接收登录、注册、加入房间、退出房间信号，分别槽函数中将数据发送给服务端。

设立信号SIG_readData(),设立槽函数SLOT_dealClientData()封装上述槽，一旦客户端收到服务端返回的数据，跳转到对应的槽函数中进行处理。

下述槽函数均由客户端主界面的点击事件触发。

```c++
//客户端收到可读信号，触发SLOT_dealClientData槽函数，其中封装了下面的登录、注册等等各个槽函数。可用策略模式完成。
SLOT_dealClientData();
//登录槽函数，发送用户名、密码给服务端验证
SLOT_loginReq();
//注册槽函数，发送用户名、密码给服务端验证
SLOT_registerReq();
//创建房间槽函数，发送房间号给服务端验证
SLOT_createRoom();
//加入房间槽函数，发送房间号给服务端验证
SLOT_joinRoom(int num);
//退出房间槽函数，发送房间号给服务端验证
SLOT_quitRoom();
//服务器向客户端发出某个客户端退出信号,在槽函数中处理，将客户端在线列表中的退出用户清除。
SLOT_clientQuit();
//音频模块每50ms从缓冲区收集数据，主函数获取数据后发送给服务端，调用QIODevice的start函数自动读取到缓冲区，然后调用write通过网络发送。SIG_AudioDataReady函数见2.4.3音频采集。
connect(this, SIGNAL(SIG_AudioDataReady(QByteArray)), this, SLOT(SLOT_sendAudioData(QByteArray)) );
SLOT_sendAudioData(QByteArray);
//接收服务端发来的数据进行混音等操作，调用音频处理模块的SLOT_PlayAudio()。
dealAudioData();
```

### 三、服务器设计

服务器模块包含三个部分：数据库、基于epoll的高并发模型、信号处理及数据收发。

#### 3.1数据库

首先创建数据库，添加**用户表**user,包含id、用户名、密码、创建时间、最后登录时间等。通过md5加密，保证用户数据安全。

```mysql
create table user (
    id bigint unsigned AUTO_INCREMENT primary key,
    username varchar (30),
    passwd varchar(30),
	Createtime DATETIME,
	LastLoginTime DATETIME)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

![image-20210806115554903](C:\Users\user\Desktop\设计文档.assets\image-20210806115554903.png)



调用c++数据库。封装成数据库连接池，单例模式获得实例。向信号处理及数据收发模块提供Init、GetConnection、QueryData、UpdateData等接口函数。

```c++
//初始化操作，参数有用户名、密码、数据库名、端口号、最大连接数量、是否开启日志等
void Init(string userName, string passWd, string dataBaseName, int Port, int MaxConn, int close_log); 
//单例模式获取数据库连接
MYSQL *GetConnection();		
//释放连接
bool ReleaseConnection(MYSQL *conn); 
//获取连接
int GetFreeConn();	
//销毁所有连接
void DestroyPool();		
//查询数据
int QueryData(char* queryStr,int nColumn,list<string>& lst);
//更新数据
int UpdateData(char *updateStr);
```

#### 3.2基于epoll的高并发模型

对信号处理及数据收发模块提供thread_pool(线程池连接)、eventListen(事件监听)、eventLoop(事件循环)、dealclinetdata(客户端连接)、dealwithsignal(信号处理)、dealwithread(读内容)、dealwithwrite(写内容)、close(关闭连接)。

```c++
//初始化线程池，便于客户端连接后分配线程处理
void thread_pool();
//封装服务器监听部分函数
void eventListen() {
    m_listenfd = socket(PF_INET, SOCK_STREAM, 0);
    ret = bind(m_listenfd, (struct sockaddr *)&address, sizeof(address));
    ret = listen(m_listenfd, 5);
    m_epollfd = epoll_create(5);
    addfd(m_epollfd, m_listenfd, false, m_LISTENTrigmode);
}
//epoll事件主循环,封装dealclinetdata(客户端连接)、dealwithsignal(信号处理)、dealwithread(读内容)、dealwithwrite(写内容)函数。
void eventLoop() {
    int number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1);
    for (int i = 0; i < number; i++)
        {
            int sockfd = events[i].data.fd;
            //处理新到的客户连接
            if (sockfd == m_listenfd)
                dealclinetdata();
            //处理信号
            else if ((sockfd == m_pipefd[0]) && (events[i].events & EPOLLIN))
                dealwithsignal(timeout, stop_server);
            //处理客户连接上接收到的数据
            else if (events[i].events & EPOLLIN)
                dealwithread(sockfd);
            else if (events[i].events & EPOLLOUT)
                dealwithwrite(sockfd);
        }
}
//关闭连接
void close(int fd);
```

#### 3.3信号处理及数据收发

- 登录请求，从数据库中验证登录信息，将结果返回给客户端
- 注册请求，从数据库中验证登录信息，将结果返回给客户端
- 创建房间请求，服务器在内存中用unordered_map保存进行验证，将结果返回给客户端。
- 加入房间请求，验证后将结果返回给客户端。
- 退出房间请求，验证后将结果返回给客户端。
- 接收多个客户端音频数据，转发给每一个客户端
- 发送房间用户列表给客户端

```c++
//验证登录请求，将结果返回给客户端
void LoginrReq(int clientFd,char* buffer,int len);
//验证注册请求，将结果返回给客户端
void RegisterReq(int clientFd,char* buffer,int len);
//验证创建房间请求，将结果返回给客户端
void CreateRoomReq(int clientFd,char* buffer,int len);
//验证加入房间请求，将结果返回给客户端
void JoinRoomReq(int clientFd,char* buffer,int len);
//验证退出房间请求，将结果返回给客户端
void QuitReq(int clientFd,char* buffer,int len);
//处理多个客户端的音频数据，将音频数据解码后返回给每一个客户端
void DealAudioData(int clientFd,char* buffer,int len);
//发送房间用户列表给客户端
void SendUserList(int userId);
```

### 四、总结

























































