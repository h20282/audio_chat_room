### 一、 设计目的 

#### 1.1功能与要求

多人语音聊天室项目由为C/S架构，分为客户端和服务端，具体需求如下。

**账号系统**

1. 支持用户注册，登录和退出。
2. 用户注册需要提供用户名和密码，用户名不可重复。

**房间**

1. 用户登录后可以创建房间，每个房间有且只有一个主持人，创建者默认为主持人，主持人可以转让给其他人。
2. 房间可以同时存在多个。
3. 房间内的用户可以听到其他用户的声音。
4. 主持人可以将若干指定用户静音，静音后所有用户不再听到被静音用户的声音，被静音用户可以主动解除静音。
5. 主持人可以将若干指定用户踢出房间。
6. 房间存在一个唯一6位数字ID，登录用户可以输入该ID加入一个房间。
7. 登录用户可以查看当前所有房间，并可选择其中一个加入。
8. 主持人退出后，房间自动解散，其他人自动退出房间。

**语音聊天**

1. 用户可以指定声音来源（包括麦克风和扬声器，可能有多个）。
2. 在正常网络下，声音每分钟明显卡顿次数小于1次，无明显延迟感。
3. 用户可以关闭房间内指定用户的声音。
4. 用户可以调节房间内指定用户的音量。

#### 1.2 环境选择

客户端的实现使用的是**Windows10**操作系统下的**QT5.12.5**, Qt是一个多平台的C++图形用户界面应用程序框架。

服务器使用的是**ubuntu18.04**,64位版本,同样安装qt作为开发环境;

数据库使用的是Linux **MySQL5.7**。

### 二、客户端设计

#### 2.1网络模块

由于音频占用带宽不大，项目暂定使用**udp**协议保证可靠性。

定义函数：

- 网络初始化：init();
- 连接到服务器：connectToServer();
- 发送数据：sendData();
- 接受数据：recvData();
- 退出服务器：DisconnectToServer();

#### 2.2登录和注册界面

![image-20210806115503046](C:\Users\user\Desktop\设计文档.assets\image-20210806115503046.png)

![image-20210806115518295](C:\Users\user\Desktop\设计文档.assets\image-20210806115518295.png)

登录注册，单击登录和注册窗口时发送信号，将用户名和密码传输给服务器。

```c++
SIG_loginReq(QString name , QString password);
SIG_registerReq(QString name , QString passord);
```

客户端界面的按钮之间的事件处理以及输入的合法性验证过程略。

服务器收到内容后做进一步处理。

- 关于登录, 处理登录请求, 先根据用户名查表取密码, 如果没有, 那么没有该用户；有的话, 比对密码 是否一致, 不一致, 返回密码错误, 一致返回登录成功。
- 关于注册，根据用户名判断是否重复，没有重复的话验证两次密码输入是否一致，一致的话通过md5加密后存入数据库，返回登录界面。
- 除此之外，登录后还需要有获取房间列表功能。

登录加密的方法:

- MD5加密
- 验证码防止脚本攻击
- 记录上次登录ip，地址等进行安全提示
- 手机验证码

#### 2.3会议模块

##### 2.3.1创建房间

![image-20210806161236209](C:\Users\user\Desktop\设计文档.assets\image-20210806161236209.png)
客户端单击星星图标发送信号，向服务端发送创建房间请求，服务器随机生成房间号返回。

```
SIG_createRoom();
```

设置模块可以选择声音来源，调节自身音量等，均属于本地资源，和服务端没有交互。

##### 2.3.2加入房间

客户端搜索房间号或单击房间列表中的房间发送信号，向服务端发送加入房间请求，服务器将客户端添加至房间列表，给房间的每一个客户端发送成员列表。

```
SIG_joinRoom(int num);
```



![image-20210806162521048](C:\Users\user\Desktop\设计文档.assets\image-20210806162521048.png)

##### 2.3.3退出房间

客户端单击x或者退出房间时回收房间资源，发送信号。服务器收到某客户端退出房间的请求后，查找房间，得到用户列表,向每一个客户端发送客户端退出房间提示，每一个客户端接受数据后删除退出的客户端的资源。

```c++
SIG_quitRoom();//客户端向服务器发出退出信号
SLOT_clientQuit();//服务器向客户端发出某个客户端退出信号，在槽函数中处理。
```

#### 2.4音频模块

##### 2.4.1基本流程和概念

对于音频，需要采集电脑麦克风声音，采用QAudioInput和QAudioOutput模块完成。

音频方面需要**编码后再传输**，编码选择 **ffmpeg** 进行处理。音频的主要流程：

![image-20210806164059828](C:\Users\user\Desktop\设计文档.assets\image-20210806164059828.png)

​        语音采集指的是从麦克风采集音频数据，即声音样本转换成数字信号。编码可以极大的减小带宽。目前有很多常用的语音编码技术，像 **G.729、G.711、.iLBC、AAC、SPEEX** 等等。

​        当一个音频帧完成编码后，即可通过网络发送给通话的对方。语音对话对于低延迟和平稳性要求较高，这就要求我们的**网络传送非常顺畅**。

​       当对方接收到编码帧后，会对其进行**解码**，以恢复成为可供声卡直接播放的数据。完成解码后，即可将得到的音频帧提交给声卡进行播放。

此外，还需要考虑一些问题：**回音消除、降噪、抑制声音断断续续、静音检测、混音**等。

- 低延迟
  - 主要取决于网络波动和双方的物理位置的距离，就单纯软件的角度，优化的可能性很小。
- 回音消除：
  - 扬声器播放时，电脑外部声音被麦克风再次采集，造成回音。 回音消除的原理简单地来说就是，回音消除模块依据刚播放的音频帧，在采集的音频帧中做一些**类似抵消的运算**，从而将回声从采集帧中清除掉。现在做的比较好的回音消除有：**webrtc。**
- 噪声抑制：
  - 噪声抑制又称为降噪处理，是根据语音数据的特点，将属于背景噪音的部分识别出来，并从音频帧中过滤掉。有很多**编码器都内置**了该功能。
- 抖动缓冲区：
  - 抖动缓冲区（JitterBuffer）用于**解决网络抖动**的问题。所谓网络抖动，就是**网络延迟一会大一会小**， 在这种情况下，即使发送方是定时发送数据包的接收方很难保证定时接收，导致听到的声音就是一卡一卡的。 JitterBuffer 工作于解码器之后，语音播放之前的环节。即语音解码完成后，将解码帧放入 JitterBuffer，声卡的播放回调到来时，从 JitterBuffer 中取出最老的一帧进行播放。**JitterBuffer 是利用了较高的延迟来换取声音的流畅播放的**，因为可以调节缓冲深度来平衡网络延迟。
- 静音检测：
  -  静音检测通常也**集成在编码模块**中。**如果没有语音输入，可以在编码头部设置特殊字符来表示**。
- 混音：
  - 在视频会议中，多人同时发言时，我们需要同时播放来自于多个人的语音数据，**而声卡播放的缓冲区只有一个，所以，需要将多路语音混合成一路**。

##### 2.4.2带宽计算

以较优异的音质效果计算，采样率48KHz，采样位数16bit，双声道计算无损无压缩格式位1536kbps。考虑采用ffmpeg对音频进行压缩，大概能压缩到128kbps左右。

##### 2.4.3音频采集

逻辑：

- 客户端接收(read)到电脑内部的声音，利用定时器每隔50ms发送(write)缓冲区的数据给服务端；`readDataAndProcess()`
- 客户端接收(read)到服务端发来数据，进行处理播放。`SLOT_PlayAudio()`
- 服务端接收(read)到客户端发来的数据，处理后发送(write)给每一个客户端。

调用QAudioInput库进行音频采集，QIODevice创建缓冲区数据保存。调用QTimer创建定时器，每50ms从缓冲区采集一次数据，进行优化处理（编码、回音消除、降噪等）后发送信号SIG_AudioDataReady给主函数，主函数定义槽SLOT_sendAudioData向服务端发送数据。

主函数dealAudioData接收音频数据。

TODO：

静音检测。需要实现音频采集暂停函数，采集重写开始函数等。

```c++
//利用定时器，每隔50ms触发事件，执行readDataAndProcess函数。
connect(timer, &QTimer::timeout, this, &Audio_Read::readDataAndProcess);
//读取数据到缓冲区，并进行降噪、编码等处理。
readDataAndProcess();
//处理完毕后emit处理完毕信号
SIG_AudioDataReady(QByteArray);
//主函数中槽函数，用来发送缓冲区的数据给服务端
SLOT_sendAudioData();
//为主函数提供接口，将接收到的音频数据进行解压，混音等操作，调用QIODevice的write函数播放声音。
SLOT_PlayAudio();
```

编解码考虑利用speex的库函数直接完成，静音和降噪考虑使用webrtc的库函数直接完成，混音考虑采用ffmpeg库函数直接完成。

#### 2.5数据传输格式

采用tcp协议，对每个请求包再次封装一个头部，服务端接收后根据头部字段分情况处理。

#### 2.6客户端主函数

客户端主函数设立多个槽函数，用来接收登录、注册、加入房间、退出房间信号，分别槽函数中将数据发送给服务端。

设立信号SIG_readData(),设立槽函数SLOT_dealClientData()封装上述槽，一旦客户端收到服务端返回的数据，如用户声音、踢人、静音用户等，跳转到对应的槽函数中进行处理。

下述槽函数均由客户端主界面的点击事件触发。

```c++
//客户端收到可读信号，触发SLOT_dealClientData槽函数，其中封装了下面的登录、注册等等各个槽函数。可用策略模式完成。
SLOT_dealClientData();
//登录槽函数，发送用户名、密码给服务端验证
SLOT_loginSubmit();
//注册槽函数，
SLOT_registerSubmit();
//创建房间槽函数
SLOT_createRoomSubmit(int roomNum);
//加入房间槽函数
SLOT_joinRoomSubmit(int roomNum);
//退出房间槽函数
SLOT_quitRoomSubmit(int roomNum);
//用户向服务端发出解除静音信号槽函数
SLOT_UnMute();
//关闭房间内指定用户的声音
SLOT_MuteOneUser(int userId);
//调节房间内指定用户的音量
SLOT_AdjustUserVolume(int userId);

//接收服务端的登录回复
DealLoginResponse();
//接收服务端的注册回复
DealRegisterResponse();
//创建房间回复
DealCreateRoomResponse(int roomNum);
//加入房间回复
DealJoinRoomResponse(int roomNum);
//退出房间回复
DealQuitRoomResponse(int roomNum);
//接收服务端发来的数据进行混音等操作，调用音频处理模块的SLOT_PlayAudio()。
DealAudioData();
//处理服务端发来的踢人处理结果,判断是否是自己。是自己调用退出房间函数。
DealForceQuitRoom();
//服务器向客户端发出某个客户端退出信号,在槽函数中处理，将客户端在线列表中的退出用户清除。
DealClientQuitResponse();


//音频模块每50ms从缓冲区收集数据，主函数获取数据后发送给服务端，调用QIODevice的start函数自动读取到缓冲区，然后调用write通过网络发送。SIG_AudioDataReady函数见2.4.3音频采集。
connect(this, SIGNAL(SIG_AudioDataReady(QByteArray)), this, SLOT(SLOT_sendAudioData(QByteArray)) );
SLOT_sendAudioData(QByteArray);
```

#### 2.7视频模块(TODO)

##### 2.7.1基本流程和概念

![image-20210806171457257](C:\Users\user\Desktop\设计文档.assets\image-20210806171457257.png)

##### 2.7.2带宽计算

​        以1920x1080的1080p视频计算，需要1920×1080=2,073,600，大约200w像素点，每个像素点包含RGB3字节工24bit，因此总共49,766,400bit，约5.9MB。以24fps计算，约**1,194,393,600‬bit=149,299,200‬byte**（8bit 比特=1byte 字节），就是142MB。

​        **YUV**代表亮度和色度，因为**RGB不利于压缩**。**通常用的是YUV4:2:0的采样方式**，能获得1/2的压缩率。

​        目前比较流行的编码格式有**H.264，H.265**。后者可以达到300的压缩率。**码流（视频文件在单位时间内使用的数据流量）**就是：**1,194,393,600‬bit ÷ 300 = 3,981,312 bit/s=3888Kbs**。

视频加音频，就是 **3,981,312 bps** + 192 kbps = 4,080 kbps。

如果要做的话可以考虑**opencv**，直接读取每一帧。

#### 2.8退出检测(TODO)

用户掉线，无法发送退出信号，借鉴tcp定时检测机制。创建定时器，完成心跳检测。

#### 2.9聊天、文件传输、断点续传(TODO)

### 三、服务器设计

### 技术点：

#### 客户端服务端如何通信

​	最基本的udp通信方式。

​	其中：

​		客户端（windows qt）：QUdpSocket

​		服务端（Linux）：socket(), bind(), recvfrom(), sendto();

#### 如何采集、播放音频

​	QAudioInput、QAudioOutput、QAudioFormat、QIODevice

#### 服务器如何收发数据

​	每收到一个客户端发送的音频数据帧都转发给其他客户端（转发前打上标记，标明来自哪个客户端）

#### 如何合成音频

​	为每个其他客户端都维护一个缓冲队列，每次播放音频帧时，都从每个队列的队首获取一个音频帧，将它们加权平均，权值的设置可实现**调节音量**的效果

![image-20210809100459156](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210809100459156.png)

### 服务器和客户端的通信

例如：
服务端收到客户端的消息：
	“请求登录” 用户名:h20282, 密码:123456
	“请求注册” 用户名:h20282, 密码:123456
	“查询房间列表”
	“查询某房间的成员列表” 房间id:123456
	“解散房间” 
	“静音用户” 被静音用户:h20282
	“转让房主” 接手人:h20282
	“退出房间”



客户端收到服务端的消息：
	“你已成为房主”
	“你已被静音”
	“你已被踢出”

#### 接口

针对以上通信需求，我们需要如下接口：

|   接口名称   |   传入参数   |  返回值  |
| :----------: | :----------: | :------: |
|     注册     | 用户名、密码 | 是否成功 |
|     登录     | 用户名、密码 | 是否成功 |
| 查询在线列表 |      无      | 在线列表 |
|   创建房间   |      无      |    无    |
| 查询房间列表 |      无      | 房间列表 |
|   解散房间   |    房间id    | 是否成功 |
|   加入房间   |    房间id    | 人员列表 |
|  主持人转让  |   接手人id   |          |
|   踢出用户   |   被踢人id   | 是否成功 |
|   静音用户   | 被静音用户id | 是否成功 |
|   退出房间   |      无      | 是否成功 |
|              |              |          |

服务端向客户端发送的消息

|      消息      |
| :------------: |
|  你已成为房主  |
|   你已被静音   |
| 你已被移出房间 |

### 角色



##### **用户**

![image-20210809093316001](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210809093316001.png)

##### **房间**

负责收发音频数据帧、管理房间内用户（房主、加入or离开房间、某是否静音）

![image-20210809093112130](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210809093112130.png)

##### **房间管理者**

用于管理房间的创建

![image-20210809093100886](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210809093100886.png)

##### **请求处理者**

用于处理来自客户端的各种请求

![image-20210809093259689](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210809093259689.png)

### 四、总结



分工、uml





















































